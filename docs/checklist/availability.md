---
title: 可用性のチェックリスト
description: 設計時の可用性に関する問題のガイダンスを提供するチェックリスト。
author: dragon119
ms.date: 01/10/2018
ms.custom: checklist
ms.openlocfilehash: 324d8200d822eb1a7dce95ba4b2a7f29b00fb291
ms.sourcegitcommit: 441185360db49cfb3cf39527b68f318d17d4cb3d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/19/2018
---
# <a name="availability-checklist"></a>可用性のチェックリスト

可用性とは、システムが機能し、動作している時間の割合であり、[ソフトウェア品質の重要な要素](../guide/pillars.md)の 1 つです。 このチェックリストを使用して、可用性の観点からアプリケーション アーキテクチャを見直します。 

## <a name="application-design"></a>アプリケーションの設計

**すべての単一障害点を回避します。** 単一障害点が可用性に影響することを防ぐため、すべてのコンポーネント、サービス、リソース、およびコンピューティング インスタンスを複数のインスタンスとして展開する必要があります。 これには認証メカニズムが含まれます。 複数のインスタンスを使用するための構成ができるように、そして自動的にエラーを検出して要求をエラーのないインスタンスにリダイレクトする (これはプラットフォームでは自動的に行われません) ようにアプリケーションを設計します。

**サービス レベル目標に基づいてワークロードを分解します。** サービスが重要なワークロードとあまり重要ではないワークロードで構成されている場合は、それらを異なる方法で管理し、それぞれの可用性の要件を満たすようにサービスの機能とインスタンスの数を指定します。

**サービスの依存関係を最少化し、把握します。** 可能な限り、使用するサービスの数を最小化し、システムに存在するすべての機能とサービスの依存関係を把握しておきます。 これには、それぞれの依存関係の性質、および各アプリケーションのエラーまたはパフォーマンス低下が全体に与える影響が含まれます。 「[回復性の要件を定義する](../resiliency/index.md#defining-your-resiliency-requirements)」をご覧ください。

**可能な限り、タスクとメッセージがべき等になるように設計します。** 操作を複数回繰り返し、同じ結果を生成できる場合、その操作はべき等です。 べき等では、重複した要求による問題の発生を防ぐことができます。 前に実行された操作を繰り返すことで結果が無効にならないように、メッセージ コンシューマーとコンシューマーが実行する操作がべき等である必要があります。 これは、重複したメッセージの検出、または競合処理のためのオプティミスティックな方法を使用した一貫性の確認を意味する場合があります。

**重要なトランザクションの高可用性を実装する、メッセージ ブローカーを使用します。** 多くのクラウド アプリケーションでは、メッセージングを使用して非同期に実行されるタスクを開始します。 メッセージの配信を保証するために、このメッセージング システムは高可用性を実現する必要があります。 [Azure Service Bus メッセージング](/azure/service-bus-messaging)は、"*少なくとも 1 回の*" セマンティクスを実装しています。 つまり、特定の状況下で重複するコピーが配信される可能性がありますが、キューに送信されたメッセージは失われません。 メッセージの処理がべき等である場合 (前の項目を参照)、繰り返しの配信は問題にはなりません。

**グレースフル デグラデーションを実現するようにアプリケーションを設計します。** アプリケーションの負荷が 1 つ以上の部分の容量を超えたことによって、可用性が低下し、接続が失敗する場合があります。 これを軽減するにはスケーリングが役立ちますが、リソースの可用性やコストなどのその他の要因によって制限に到達する可能性があります。 アプリケーションがリソースの上限に達したときに、適切なアクションを実行してユーザーへの影響を最小限に抑える必要があります。 たとえば、電子商取引システムで注文処理サブシステムに負荷がかかっている場合やエラーが発生した場合は、サブシステムを一時的に無効にし、他の機能 (製品カタログの参照など) を続行することができます。 エラーが発生しているサブシステムへの要求を遅らせることが適切な場合があります。たとえば、顧客が注文を送信し、その注文を注文サブシステムが再度使用可能になったら後で処理できるように保存することができます。

**急速なバースト イベントを適切に処理します。** ほとんどのアプリケーションでは、経時的に変化するワークロードを処理する必要があります。 自動スケールは負荷の処理に役立ちますが、追加のインスタンスがオンラインになり、要求を処理するまでに時間がかかる場合があります。 アクティビティで突然、予期しないバーストが発生してもアプリケーションで過負荷が発生しないようにします。これには、キューが容量に近づいたら使用するサービスに要求のキューを入れ、適切に機能が低下するように設計します。 バーストしない条件下で、キューを排出して未処理の要求を処理するために十分なパフォーマンスと容量を確保できることを確認します。 詳細については、「[Queue-Based Load Leveling Pattern (キュー ベースの負荷平準化パターン)](https://msdn.microsoft.com/library/dn589783.aspx)」を参照してください。

## <a name="deployment-and-maintenance"></a>展開と保守

**複数のインスタンスのサービスをデプロイします。** アプリケーションがサービスの 1 つのインスタンスに依存する場合は、単一障害点が発生します。 複数のインスタンスをプロビジョニングすると、回復性とスケーラビリティの両方が改善されます。 [Azure App Service](/azure/app-service/app-service-value-prop-what-is/) の場合は、複数のインスタンスを提供する [App Service プラン](/azure/app-service/azure-web-sites-web-hosting-plans-in-depth-overview/)を選択してください。 Azure Cloud Services の場合は、[複数インスタンス](/azure/cloud-services/cloud-services-choose-me/#scaling-and-management)を使用するように各ロールを構成してください。 [Azure Virtual Machines (VM)](/azure/virtual-machines/virtual-machines-windows-about/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) の場合は、VM アーキテクチャに 1 つ以上の VM が含まれていることと、[可用性セット][availability-sets]に各 VM が含まれていることを確認してください。

**アプリケーションを複数のリージョンにデプロイすることを検討します。** アプリケーションが 1 つのリージョンにデプロイされている場合は、まれにリージョン全体が使用できなくなった場合に、アプリケーションも使用できなくなります。 これは、アプリケーションの SLA の条件の下では許容できないことがあります。 その場合は、アプリケーションとそのサービスを複数のリージョンにデプロイすることを検討してください。

**デプロイおよび保守のタスクを自動化してテストします。** 分散アプリケーションは、連携して動作する必要がある、複数の部分で構成されます。 スクリプトなどのテスト済みおよび実証済みのメカニズムを使用して、デプロイを自動化する必要があります。 これらのメカニズムでは、構成を更新および検証し、デプロイ プロセスを自動化することができます。 [Azure Resource Manager テンプレート](/azure/azure-resource-manager/resource-group-authoring-templates)を使用して Azure リソースをプロビジョニングします。 また、アプリケーションの更新を実行する自動化された手法も使用します。 エラーによってさらにダウンタイムが発生しないように、このすべてのプロセスを完全にテストすることが不可欠です。 すべての展開ツールには展開されたアプリケーションを保護するための、適切なセキュリティ制限が必要です。展開ポリシーは慎重に定義して適用し、人間の介入は最小限に抑えてください。

**プラットフォームのステージングおよび運用機能を使用します。** たとえば、Azure App Service では、デプロイを運用環境に切り替える前のステージングに使用できる[展開スロット](/azure/app-service/web-sites-staged-publishing)をサポートします。 Azure Service Fabric では、アプリケーション サービスの[ローリング アップグレード](/azure/service-fabric/service-fabric-application-upgrade)をサポートします。

**仮想マシン (VM) を可用性セットに配置します。** 可用性を最大限にするには、各 VM ロールの複数のインスタンスを作成し、それらのインスタンスを同じ可用性セットに配置します。 異なるアプリケーション層など、さまざまなロールが適用された複数の VM がある場合は、VM ロールごとに可用性セットを作成します。 たとえば、Web 層の可用性セットを作成し、データ層には別の可用性セットを作成します。

## <a name="data-management"></a>[データ管理]

**Azure Storage のデータの geo レプリケーション**。 Azure Storage 内のデータは、データセンター内で自動的にレプリケートされます。 さらに高い可用性を実現するには、読み取りアクセス geo 冗長ストレージを使用して (RAGRS)、セカンダリ リージョンにデータをレプリケートし、セカンダリ ロケーションのデータに読み取り専用のアクセスを付与します。 地域全体が停電になった場合や災害が発生した場合でも、データは保持されます。 詳細については、「[Azure Storage のレプリケーション](/azure/storage/storage-redundancy)」をご覧ください。

**データベースの geo レプリケーション**。 Azure SQL Database と Cosmos DB は、どちらも geo レプリケーションをサポートしており、他のリージョンでセカンダリ データベースのレプリカを構成できるようになっています。 セカンダリ データベースは、データ センターで障害が発生した場合やプライマリ データベースに接続できない場合のクエリとフェールオーバーに使用できます。 詳細については、[フェールオーバー グループとアクティブ geo レプリケーション](/azure/sql-database/sql-database-geo-replication-overview) (SQL Database) に関する記事、および「[Azure Cosmos DB を使用してデータをグローバルに分散させる方法](/azure/cosmos-db/distribute-data-globally)」をご覧ください。

**オプティミスティック同時実行制御と最終的な整合性を使用します。** ロックによってリソースへのアクセスをブロックするトランザクション (ペシミスティック同時実行制御) では、パフォーマンスが低下し、可用性も大幅に低下する場合があります。 これらの問題は、分散システムで特に深刻になります。 多くの場合、パーティション分割などの入念な設計や技法によって、更新プログラムの競合が発生する可能性を最小限に抑えることができます。 データがレプリケートされたり、個別に更新されたスコアから読み取られたりすると、最終段階でのみ、データの一貫性が確保されます。 ただし、通常、その利点は、即座に一貫性を確保するトランザクションを使用できることに対する効果を大きく上回ります。

**定期的なバックアップとポイントインタイム リストアを使用します。** 他の場所には保存されないデータを定期的に自動でバックアップして、障害発生時でもデータとアプリケーション自体の両方を安全に復元できることを確認します。 バックアップが目標復旧時点 (RPO) を満たしていることを確認します。 データ レプリケーションはバックアップ機能ではありません。人為的なミスや悪意のある操作によって、すべてのレプリカでデータが破損する可能性があるためです。 バックアップ プロセスは、転送中のデータと格納中のデータを保護するため、セキュリティで保護する必要があります。 データベースまたはデータ ストアの一部は通常、トランザクション ログを使用して前の時点まで回復することができます。 詳細については、「[Recover from data corruption or accidental deletion (データの破損または偶発的な削除からの復旧)](../resiliency/recovery-data-corruption.md)」をご覧ください。

## <a name="errors-and-failures"></a>エラーと障害

**要求タイムアウトを構成します。** サービスとリソースが使用不可能になり、要求が失敗する原因となる場合があります。 適用するタイムアウトが各サービスまたはリソースに加え、それらにアクセスしているクライアントに適切であるかどうかを確認します  コンテキストやクライアントが実行しているアクションによっては、クライアントの特定のインスタンスのタイムアウトを長くすることができる場合もあります。 タイムアウトが短すぎると、待機時間が非常に長いサービスとリソースで過剰な再試行操作が発生する可能性があります。 また、タイムアウトが長すぎると、大量の要求がキューにあり、サービスまたはリソースの応答を待機している場合にブロックが発生する可能性があります。

**一時的な障害により失敗した操作を再試行します。** 本来は自動的な接続再試行をサポートしていないすべてのサービスおよびリソースにアクセスするための再試行戦略を設計します。 リソースのオーバーロードを防ぎ、キューに登録されている要求を適切に復元して処理できるように、障害の数が増えるにつれて再試行の間の遅延が増加するような戦略を使用します。 非常に短い遅延の再試行が連続すると、問題が悪化する可能性があります。 詳細については、「[特定のサービスの再試行ガイダンス](../best-practices/retry-service-specific.md)」を参照してください。

**サーキット ブレークを実装して連鎖的な障害を回避します。** 一時的またはその他の障害で、接続の部分的な損失からサービス全体の障害まで重要度が多岐にわたる場合、通常の状態に戻るまでに予想よりも時間がかかる場合があります。 サービスが非常にビジーな状態で、メモリ、スレッド、データベース接続などの重要なシステム リソースが使用されていると、システムの 1 つの部分の障害が連鎖的な障害に発展し、多くの操作がブロックされる場合があります。 アプリケーションは、成功の見込みのない操作を継続的に再試行するのではなく、操作が失敗していることを迅速に受け入れ、このエラーを適切に処理する必要があります。 サーキット ブレーカー パターンを使用して、一定期間、特定の操作の要求を拒否します。 詳細については、「[Circuit Breaker Pattern (Circuit Breaker パターン)](../patterns/circuit-breaker.md)」をご覧ください。

**複数のコンポーネントを構成するか、複数のコンポーネントにフォールバックします。** 操作や既存の接続になるべく影響を与えずに複数のインスタンスを使用するようにアプリケーションを設計します。 可用性を最大化するため、複数のインスタンスを使用してそれらの間に要求を分散し、失敗したインスタンスへの要求の送信を検出して回避します。

**別のサービスまたはワークフローにフォールバックします。** たとえば、SQL Database への書き込みに失敗した場合は、一時的にデータを Blob Storage または Redis Cache に保存します。 サービスが利用可能になったときに SQL Database への書き込みを再生する方法を提供します。 失敗した操作には、コンポーネントまたはサービスが失敗してもアプリケーションが動作し続けられるような代替の操作がある場合もあります。 可能であれば、エラーを検出し、適切な代替機能を提供できる他のサービスか、プライマリ サービスがオフラインの間もコアな操作を維持できるバックアップ機能または制限された機能のインスタンスに要求をリダイレクトします。

## <a name="monitoring-and-disaster-recovery"></a>監視と障害復旧

**可能性の高い障害や障害イベントの豊富なインストルメンテーションを提供します** 。 可能性が高いがまだ発生していない障害については、運用スタッフが原因を判別し、状況を緩和し、システムが引き続き使用できるようにするための十分なデータを提供します。 既に発生している障害については、アプリケーションがユーザーに適切なエラー メッセージを返しながらも、機能が制限された状態で実行を続行しようとする必要があります。 どの場合も、監視システムは運用スタッフが迅速な回復が行えるように包括的な詳細をキャプチャし、必要に応じてデザイナーと開発者が状況の再発を防ぐため、システムを修正する必要があります。

**チェック機能を実装することでシステム正常性を監視します。** アプリケーションの正常性とパフォーマンスは、時間の経過と共に低下し、障害が発生するまで気づかない場合があります。 アプリケーションの外部から定期的に実行されるプローブやチェック機能を実装してください。 これらのチェックは、アプリケーション全体、アプリケーションの個々 の部分、アプリケーションが使用する個々 のサービス、または個々 のコンポーネントの応答時間を測定するのと同じくらい単純にすることができます。 チェック機能はプロセスを実行することで、有効な結果が生成され、待機時間とチェック機能が測定され、システムから情報が抽出されていることを確認できます。

**すべてのフェールオーバーおよびフォールバック システムを定期的にテストします。** システムおよび操作の変更はフェールオーバーおよびフォールバック機能に影響を与える可能性がありますが、その影響はメインのシステムで障害が発生するか、オーバーロードが発生するまで検出されない場合があります。 実行時に、発生中の問題を補正しなければならなくなる前にテストしてください。

**監視システムをテストします。** 自動フェールオーバーとフォールバック システム、およびダッシュボードを使用したシステム正常性とパフォーマンスの手動の視覚化はすべて、正常に機能している監視およびインストルメンテーションに依存しています。 これらの要素で障害、重要な情報の不足、不適切なデータの報告が発生すると、オペレーターはシステムが正常でないことやシステムで障害が発生していることに気付かない可能性があります。

**実行時間の長いワークフローの進行状況を追跡し、障害発生時に再試行します。** 実行時間の長いワークフローは多くの場合、複数の手順で構成されています。 各手順が独立していること、および各手順の再試行によってワークフロー全体のロールバックや、複数の補正トランザクションを実行しなければならない事態が最小限に抑えられることを確認します。 [Scheduler Agent Supervisor パターン](../patterns/scheduler-agent-supervisor.md)などのパターンを実装して、実行時間の長いワークフローの進行状況を監視し、管理します。

**障害復旧を計画します。** 十分なテストを実施した許容可能な計画を作成し、システムの可用性に影響を及ぼす可能性のある、あらゆる種類の障害から復旧できるようにします。 ミッションクリティカルなあらゆるアプリケーションに対応できる、マルチサイトのディザスター リカバリー アーキテクチャを選択します。 自動化やテストも含めたディザスター リカバリー プランの特定のオーナーを指定します。 計画の内容が詳細に文書化されていることを確認し、可能な限り、プロセスを自動化します。 すべての参照データとトランザクション データに対してバックアップ戦略を確立し、これらのバックアップの復元を定期的にテストします。 運用スタッフに対して計画実行のトレーニングを行うと共に、災害のシミュレーションを定期的に実施して計画を検証、および改善します。

<!-- links -->
[availability-sets]:/azure/virtual-machines/virtual-machines-windows-manage-availability/
