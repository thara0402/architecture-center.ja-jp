---
title: CAF:Azure での複数チーム向けのガバナンス設計
titleSuffix: Microsoft Cloud Adoption Framework for Azure
ms.service: architecture-center
ms.subservice: enterprise-cloud-adoption
ms.custom: governance
description: 複数のチーム、複数のワークロード、および複数の環境を対象とした Azure ガバナンス管理を構成するためのガイダンス
author: petertaylor9999
ms.date: 2/11/2019
ms.openlocfilehash: d0f3256e1d7b752789efd709f917e4eb2e996175
ms.sourcegitcommit: 273e690c0cfabbc3822089c7d8bc743ef41d2b6e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/08/2019
ms.locfileid: "55901870"
---
# <a name="governance-design-for-multiple-teams"></a>複数チーム向けのガバナンス設計

このガイドの目的は、複数チーム、複数ワークロード、および複数環境をサポートする、Azure におけるリソース ガバナンス モデルの設計プロセスについて説明することです。 まず、一連のガバナンス要件を例として挙げて、これらの要件に対応する実装サンプルをいくつか紹介します。

要件は次のとおりです。

- 新しいクラウドのロールと責任を一連のユーザーに移行しようとしている企業が、Azure でさまざまなリソース アクセス ニーズを持つ複数チームを対象とした ID 管理を必要としています。 この ID 管理システムには、次のユーザーの ID を格納する必要があります。
  1. **サブスクリプション**の所有を担当する、ご自身の組織内の個人。
  2. ご自身のオンプレミス ネットワークを Azure 仮想ネットワークに接続するときに使用される**共有インフラストラクチャ リソース**を担当する、ご自身の組織内の個人。
  3. **ワークロード**の管理を担当する、ご自身の組織内の個人 (2 人)。
- 複数の**環境**のサポート。 環境とは、仮想マシン、仮想ネットワーク、ネットワーク トラフィックのルーティング サービスなど、リソースの論理的グループのことです。 これらのリソース グループは、管理およびセキュリティ要件が類似しており、通常は、テストや運用などの特定の目的で使用されます。 この例では、要件は次の 3 つの環境に対応しています。
  1. **共有インフラストラクチャ環境**: 他の環境のワークロードによって共有されるリソースが含まれます。 オンプレミスへの接続性を提供するゲートウェイ サブネットを含む仮想ネットワークなど。
  2. **運用環境**: 最も制限の厳しいセキュリティ ポリシーが適用されます。 内部または外部に接続されるワークロードを含めることができます。
  3. **開発環境**: 概念実証とテストを行うための環境です。 この環境のセキュリティ、コンプライアンス、およびコストの各ポリシーは、運用環境のものとは異なります。
- **最小限の特権のアクセス許可モデル**。既定では、アクセス許可がユーザーに付与されていません。 このモデルは以下をサポートする必要があります。
  - リソース アクセス権を割り当てるアクセス許可を持つ、サブスクリプション スコープの 1 人の信頼されたユーザー。
  - リソースへの各ワークロード所有者によるアクセスが既定で拒否されている。 リソース アクセス権は、サブスクリプション スコープの 1 人の信頼されたユーザーによって明示的に付与されます。
  - 共有インフラストラクチャ リソースへの管理アクセスが、インフラストラクチャ所有者に制限されている。
  - 各ワークロードへの管理アクセスが、ワークロード所有者に制限されている。
  - この企業は 3 つの環境それぞれで個別にロールを管理しなければならな状況を望んでいないため、[組み込み RBAC ロール][rbac-built-in-roles]のみを使用する必要がある。 仮にこの企業がカスタム RBAC ロールを使うとすると、3 つの環境でカスタム ロールを同期させるために、追加のプロセスが必要になる。
- ワークロード所有者名、環境、またはその両方でコストを追跡。

## <a name="identity-management"></a>ID 管理

ご自身のガバナンス モデルの ID 管理を設計する前に、次の 4 つの主な領域について理解しておくことが重要です。

- 管理: ユーザー ID を作成、編集、および削除するためのプロセスとツール。
- 認証: ユーザー名、パスワードなどの資格情報を検証することにより、ユーザー ID を確認すること。
- 承認: 認証されたユーザーがアクセスできるリソースや、そのユーザーが実行できる操作を決定すること。
- 監査: ログまたはその他の情報を定期的に確認して、ユーザー ID に関連するセキュリティの問題を検出すること。 これには、不審な使用パターンがないかどうかを確認する、ユーザーのアクセス許可が正しいかどうかを定期的に確認する、などが含まれます。

ID に関して Azure が信頼するサービスは Azure Active Directory (Azure AD) の 1 つだけです。 ここではユーザーを Azure AD に追加し、前に示したすべての領域に対して使用しますが、 Azure AD の構成方法を見る前に、これらのサービスへのアクセスの管理に使用される特権アカウントについて理解しておくことが重要です。

ご自身の組織が Azure アカウントにサインアップしたときに、少なくとも 1 つの Azure **アカウント所有者**が割り当てられています。 また、既存のテナントが、ご自身の組織で使用している他の Microsoft サービス (Office 365 など) にまだ関連付けられていなかった場合は、Azure AD **テナント**が作成されています。 Azure AD テナントに対する完全なアクセス許可を持つ**グローバル管理者**が、そのテナントの作成時に関連付けられました。

Azure アカウント所有者と Azure AD グローバル管理者の両方のユーザー ID が、Microsoft によって管理されている安全性の高い ID システムに格納されています。 Azure アカウント所有者には、サブスクリプションを作成、更新、および削除する権限があります。 Azure AD グローバル管理者が Azure AD で許可されているアクションは多数ありますが、この設計ガイドでは、ユーザー ID の作成と削除に注目します。

> [!NOTE]
> お使いのアカウントに既存の Office 365 または Intune ライセンスが関連付けられている場合は、ご自身の組織に Azure AD テナントが既に存在することがあります。

Azure アカウント所有者には、サブスクリプションを作成、更新、および削除するアクセス許可が付与されています。

![Azure アカウント マネージャーと Azure AD グローバル管理者が含まれる Azure アカウント](../../_images/governance-3-0.png)
*図 1. Azure アカウント マネージャーと Azure AD グローバル管理者が含まれる Azure アカウント。*

Azure AD **グローバル管理者**には、ユーザー アカウントを作成するアクセス許可が付与されています。

![Azure アカウント マネージャーと Azure AD グローバル管理者が含まれる Azure アカウント](../../_images/governance-3-0a.png)
*図 2. Azure AD グローバル管理者は必要なユーザー アカウントをテナントに作成する。*

最初の 2 つのアカウント **App1 ワークロード所有者**と **App2 ワークロード所有者**はそれぞれ、ワークロードの管理を担当するご自身の組織内の個人に関連付けられています。 **ネットワーク操作**アカウントは、共有インフラストラクチャ リソースを担当する個人が所有します。 最後の**サブスクリプション所有者**アカウントは、サブスクリプションの所有権を担当する個人と関連付けられています。

## <a name="resource-access-permissions-model-of-least-privilege"></a>最小限の特権のリソース アクセスのアクセス許可モデル

ご自身の ID 管理システムとユーザー アカウントが作成されたので、次は、最小限の特権のアクセス許可モデルをサポートするために、ロールベースのアクセス制御 (RBAC) ロールを各アカウントに適用する方法を決める必要があります。

また、ワークロード所有者が自身の所有していない他のワークロードに管理アクセスできないように、各ワークロードに関連付けられているリソースがそれぞれ互いに分離されていなければならないというもう 1 つの要件があります。 さらに、このモデルは、[Azure RBAC の組み込みロール][rbac-built-in-roles]のみを使用して、実装するという要件もあります。

それぞれの RBAC ロールが、**サブスクリプション**、**リソース グループ**、個別の**リソース**の 3 つのスコープのいずれかで適用されます。 ロールは下位のスコープに継承されます。 たとえば、ユーザーに[組み込み所有者ロール][rbac-built-in-owner]がサブスクリプション レベルで割り当てられている場合、そのロールは、オーバーライドされない限り、リソース グループおよび個別のリソース レベルでもユーザーに割り当てられます。

そのため、最小限の特権アクセスのモデルを作成するには、特定のタイプのユーザーが 3 つの各スコープで実行できるアクションを決める必要があります。 たとえば、ここでは、ワークロード所有者には、自身のワークロードに関連付けられているリソースのみに対する管理アクセス許可を付与し、他のリソースは管理できないようにする必要があります。 [組み込み所有者ロール][rbac-built-in-owner]をサブスクリプション スコープで割り当てると、各ワークロード所有者はすべてのワークロードへの管理アクセス権を持つことになります。

この概念がもう少しわかるように、2 つのアクセス許可モデルの例を見てみましょう。 最初の例のモデルでは、サービス管理者のみを信頼してリソース グループを作成します。 2 番目の例のモデルでは、組み込み所有者ロールを、サブスクリプション スコープの各ワークロード所有者に割り当てます。

両方の例に、サブスクリプション スコープで[組み込み所有者ロール][rbac-built-in-owner]が割り当てられているサブスクリプション サービス管理者がいます。 [組み込み所有者ロール][rbac-built-in-owner]によって、リソースへのアクセス管理を含むすべてのアクセス許可が付与されることを思い出してください。
![所有者ロールを持つサブスクリプション サービス管理者](../../_images/governance-2-1.png)
*図 3. 組み込み所有者ロールが割り当てられたサービス管理者が含まれるサブスクリプション。*

1. 最初の例の**ワークロード所有者 A** にはサブスクリプション スコープのアクセス許可がありません。つまり、既定では、この所有者にはリソース アクセス管理のアクセス権がありません。 このユーザーは、そのワークロードに対応したリソースを展開して管理する必要があります。 ワークロード所有者は**サービス管理者**に、リソース グループを作成するように要求する必要があります。
    ![ワークロード所有者がリソース グループ A の作成を要求する](../../_images/governance-2-2.png)
2. **サービス管理者**はその要求を確認し、**リソース グループ A** を作成します。この時点では、まだ**ワークロード所有者 A** にはアクセス許可がないため、何もできません。
    ![サービス管理者がリソース グループ A を作成する](../../_images/governance-2-3.png)
3. **サービス管理者**は**ワークロード所有者 A** を**リソース グループ A** に追加し、[組み込み共同作成者ロール](/azure/role-based-access-control/built-in-roles#contributor)を割り当てます。 共同作成者ロールによって、**リソース グループ A** には、アクセス管理を除くすべてのアクセス許可が付与されます。
    ![サービス管理者がワークロード所有者 A をリソース グループ A に追加する](../../_images/governance-2-4.png)
4. **ワークロード所有者 A** は、ワークロードの容量計画の一環として、2 人のチーム メンバーが CPU とネットワーク トラフィック監視データを確認できるようにする必要があるとします。 **ワークロード所有者 A** には共同作成者ロールが割り当てられているため、ユーザーを**リソース グループ A** に追加するアクセス許可はありません。そこで、この要求を**サービス管理者**に送信する必要があります。
    ![ワークロード所有者が、リソース グループへのワークロード共同作成者の追加を要求する](../../_images/governance-2-5.png)
5. **サービス管理者**は要求を確認し、2 人の**ワークロードの共同作成者**ユーザーを**リソース グループ A** に追加します。この 2 人のユーザーにはリソース管理のアクセス許可は必要ありません。したがって、[組み込み閲覧者ロール](/azure/role-based-access-control/built-in-roles#contributor)が割り当てられます。
    ![サービス管理者がワークロード共同作成者をリソース グループ A に追加する](../../_images/governance-2-6.png)
6. さらに、**ワークロード所有者 B** も、自身のワークロードに対するリソースをリソース グループに追加する必要があります。 **ワークロード所有者 A** と同様、**ワークロード所有者 B** にも、サブスクリプション スコープでアクションを実行するためのアクセス許可が最初は付与されていません。そこで、ワークロード所有者 B も**サービス管理者**に要求を送信する必要があります。
    ![ワークロード所有者 B がリソース グループ B の作成を要求する](../../_images/governance-2-7.png)
7. **サービス管理者**はその要求を確認し、**リソース グループ B** を作成します。![サービス管理者がリソース グループ B を作成する](../../_images/governance-2-8.png)
8. 次に、**サービス管理者**は**ワークロード所有者 B** を**リソース グループ B** に追加し、[組み込み共同作成者ロール](/azure/role-based-access-control/built-in-roles#contributor)を割り当てます。
    ![サービス管理者がワークロード所有者 B をリソース グループ B に追加する](../../_images/governance-2-9.png)

この時点で、ワークロード所有者はそれぞれ、自身のリソース グループで孤立しています。 ワークロード所有者またはそのチーム メンバーが、他のリソース グループのリソースに管理アクセスすることはできません。

![リソース グループ A とリソース グループ B が含まれるサブスクリプション](../../_images/governance-2-10.png)
*図 4. それぞれのリソース グループで孤立している 2 人のワークロード所有者が含まれるサブスクリプション。*

これは最小限の特権モデルです。このモデルでは、各ユーザーに、適切なアクセス許可が適切なリソース管理スコープで割り当てられています。

ただし、この例では、すべてのタスクが**サービス管理者**によって実行されたことに注意してください。 この例ではワークロード所有者が 2 人しかいなかったため、シンプルで、問題がないように見えますが、大規模な組織では問題が発生するのは想像に難くありません。 たとえば、要求のバックログが大きくなれば、**サービス管理者**がボトルネックとなる可能性があり、これが遅延につながります。

次の 2 番目の例では、**サービス管理者**によって実行されるタスク数が減っています。

1. このモデルでは、サブスクリプション スコープで**ワークロード所有者 A** に[組み込み所有者ロール][rbac-built-in-owner]が割り当てられており、そのワークロード所有者 A は、自身のリソース グループとして**リソース グループ A** を作成できます。![サービス管理者がワークロード所有者 A をサブスクリプションに追加する](../../_images/governance-2-11.png)
2. **リソース グループ A** が作成されるとき、**ワークロード所有者 A** が既定で追加され、この所有者は、[組み込み所有者][rbac-built-in-owner]ロールをサブスクリプション スコープから継承します。
    ![ワークロード所有者 A がリソース グループ A を作成する](../../_images/governance-2-12.png)
3. [組み込み所有者ロール][rbac-built-in-owner]により、**ワークロード所有者 A** に、リソース グループへのアクセスを管理するアクセス許可が付与されます。 **ワークロード所有者 A** が 2 人の**ワークロード共同作成者**を追加し、それぞれに[組み込み閲覧者ロール][rbac-built-in-owner]を割り当てます。
    ![ワークロード所有者 A がワークロード共同作成者を追加する](../../_images/governance-2-13.png)
4. ここで、**サービス管理者**が、**ワークロード所有者 B** を、組み込み所有者ロールが含まれるサブスクリプションに追加します。
    ![サービス管理者がワークロード所有者 B をサブスクリプションに追加する](../../_images/governance-2-14.png)
5. **ワークロード所有者 B** が**リソース グループ B** を作成します。ワークロード所有者 B は既定で追加されています。 前と同様、**ワークロード所有者 B** は、組み込み所有者ロールをサブスクリプション スコープから継承します。
    ![ワークロード所有者 B がリソース グループ B を作成する](../../_images/governance-2-15.png)

このモデルでは、**サービス管理者**が実行するアクションが、最初の例よりも少なくなっていることに注意してください。これはそれぞれのワークロード所有者に管理アクセスが委任されているためです。

![リソース グループ A とリソース グループ B が含まれるサブスクリプション](../../_images/governance-2-16.png)
*図 5. 組み込み所有者ロールが割り当てられた、サービス管理者と 2 人のワークロード所有者が含まれるサブスクリプション。*

ただし、サブスクリプション スコープで**ワークロード所有者 A** と**ワークロード所有者 B** の両方に組み込み所有者ロールが割り当てられているため、それぞれが、お互いのリソース グループの組み込み所有者ロールを継承しています。 つまり、両方の所有者は、お互いのリソースにフル アクセスできるだけでなく、管理アクセスを、お互いのリソース グループに委任することもできます。 たとえば、**ワークロード所有者 B** が他のユーザーを**リソース グループ A** に追加し、組み込み所有者ロールなど、任意のロールを割り当てることができます。

それぞれの例を要件と比較すると、この 2 つの例では、2 人のワークロード所有者にリソース アクセス権を付与するアクセス許可を持つ 1 人の信頼されたユーザーがサブスクリプション スコープでサポートされていることがわかります。 2 人のワークロード所有者は、既定では、リソース管理にアクセスできなかったため、**サービス管理者**に、アクセス許可を明示的に割り当ててもらう必要がありました。 ただし、最初の例のみが、ワークロード所有者が他のワークロードのリソースにアクセスできないように、各ワークロードに関連付けられているリソースがお互いに独立していなければならない、という要件に対応しています。

## <a name="resource-management-model"></a>リソース管理モデル

これで、最小限の特権のアクセス許可モデルの設計が完了しました。次は、これらのガバナンス モデルの実際の適用例をいくつか見ていきましょう。 次の 3 つの環境をサポートする必要がある、という要件を思い出してください。

1. **共有インフラストラクチャ:** すべてのワークロードで共有されるリソースの 1 つのグループ。 ネットワーク ゲートウェイ、ファイアウォール、セキュリティ サービスなどのリソースです。
2. **開発:** 複数の非運用対応ワークロードを表す複数のリソース グループ。 これらのリソースは、概念実証、テスト、およびその他の開発者アクティビティ用に使用されます。 これらのリソースのガバナンス モデルは、開発者の俊敏性を高めることができるように、もっと緩やかなものにしてもかまいません。
3. **運用:** 複数の運用ワークロードを表す複数のリソース グループ。 これらのリソースは、プライベートとパブリックのアプリケーション成果物のホストに使用されます。 これらのリソースでは、リソース、アプリケーション コード、およびデータを不正アクセスから保護するために、通常、最も厳しいガバナンスおよびセキュリティ モデルが採用されています。

この 3 つの環境ごとに、**ワークロード所有者**、**環境**、またはその両方について、コスト データを追跡する必要があります。 つまり、**共有インフラストラクチャ**の継続的なコスト、**開発**環境と**運用**環境の両方の個人によって発生するコスト、最終的には**開発**と**運用**の全体的コストを把握する必要があります。

リソースのスコープには、**サブスクリプション**と**リソース グループ**の 2 つのレベルがあることは既に説明しました。 したがって、最初に、**サブスクリプション**によって環境を整理する方法を決めます。 可能性は 2 つしかありません。1 つのサブスクリプション、そして複数のサブスクリプションです。

それぞれのモデルの例を見る前に、Azure 内のサブスクリプションの管理構造を確認しましょう。

サブスクリプションを担当する個人が組織にいる、という要件を思い出してください。このユーザーは、Azure AD テナント内で**サブスクリプション所有者**アカウントを所有しています。 ただし、このアカウントには、サブスクリプションを作成するためのアクセス許可がありません。 これを行うアクセス許可を持っているのは **Azure アカウント所有者**だけです。

![Azure アカウント所有者がサブスクリプションを作成する](../../_images/governance-3-0b.png)
*図 6. Azure アカウント所有者がサブスクリプションを作成する。*

サブスクリプションが作成されたら、**Azure アカウント所有者**は、**サブスクリプション所有者**アカウントを、**所有者**ロールと共にサブスクリプションに追加できます。

![Azure アカウント所有者は、サブスクリプション所有者ユーザー アカウントを所有者ロールと共にサブスクリプションに追加する。](../../_images/governance-3-0c.png)
*図 7. Azure アカウント所有者は、**サブスクリプション所有者**ユーザー アカウントを**所有者**ロールと共にサブスクリプションに追加する。*

これで、**サブスクリプション所有者**は、**リソース グループ**を作成して、リソース アクセス管理を委任できます。

まず、1 つのサブスクリプションを使用したリソース管理モデルの例を見てみましょう。 最初に、リソース グループを 3 つの環境と連携させる方法を決めます。 2 つのオプションがあります。

1. 各環境を 1 つのリソース グループと連携させる。 共有インフラストラクチャ リソースはすべて、1 つの**共有インフラストラクチャ** リソース グループにデプロイされます。 開発ワークロードに関連付けられているリソースはすべて、1 つの**開発**リソース グループにデプロイされます。 運用ワークロードに関連付けられているリソースについては、**運用**環境の 1 つの**運用**リソース グループにすべてデプロイされます。
2. ワークロードごとに個別のリソース グループを作成し、名前付け規則とタグを使用して、そのリソース グループを 3 つの環境それぞれと連携させる。

まずは、最初のオプションについて考えてみましょう。 ここでは、前のセクションで説明したアクセス許可モデルと、1 人のサブスクリプション サービス管理者を使用します。この管理者は、リソース グループを作成し、そのグループに、ユーザーを、組み込み**共同作成者**ロールまたは**閲覧者**ロールと共に追加します。

1. デプロイされた最初のリソース グループは、**共有インフラストラクチャ**環境を表します。 **サブスクリプション所有者**は、`netops-shared-rg` という名前の共有インフラストラクチャ リソースのリソース グループを作成します。
    ![](../../_images/governance-3-0d.png)
2. **サブスクリプション所有者**は、**ネットワーク操作ユーザー** アカウントをそのリソース グループに追加し、**共同作成者**ロールを割り当てます。
    ![](../../_images/governance-3-0e.png)
3. **ネットワーク操作ユーザー**は、[VPN ゲートウェイ](/azure/vpn-gateway/vpn-gateway-about-vpngateways)を作成し、オンプレミス VPN アプライアンスに接続するように構成します。 また、**ネットワーク操作ユーザー**は、*environment:shared* および *managedBy:netOps* という[タグ](/azure/azure-resource-manager/resource-group-using-tags)のペアを各リソースに適用します。 **サブスクリプション サービス管理者**がコスト レポートをエクスポートすると、それぞれのタグに合わせてコストが調整されます。 これにより、**サブスクリプション サービス管理者**が、*environment* タグ *managedBy* タグを使ってコストをピボットできます。 図の右上にある**リソース制限**カウンターをご覧ください。 各 Azure サブスクリプションに[サービス制限](/azure/azure-subscription-service-limits)があります。これらの制限の影響について理解しやすいように、ここでは各サブスクリプションの仮想ネットワークの制限を追跡します。 サブスクリプションあたりの仮想ネットワークの制限は 1,000 です。1 つ目の仮想ネットワークがデプロイされたため、現在 999 の仮想ネットワークが使用可能です。
    ![](../../_images/governance-3-1.png)
4. さらに 2 つのリソース グループがデプロイされます。 1 つ目の名前は `prod-rg` です。 このリソース グループは運用環境と連携します。 2 つ目の名前は `dev-rg` で、開発環境と連携します。 運用ワークロードに関連付けられているリソースはすべて、運用環境にデプロイされ、開発ワークロードに関連付けられているリソースはすべて、開発環境にデプロイされます。 この例では、この 2 つの環境それぞれにデプロイするワークロードは 2 つだけなので、Azure サブスクリプション サービスの制限に達することはありません。 しかし、リソース数の上限がリソース グループあたり 800 であることを考慮してください。 各リソース グループにワークロードを追加し続けると、最終的にこの制限に到達します。
    ![](../../_images/governance-3-2.png)
5. 最初の**ワークロード所有者**が要求を**サブスクリプション サービス管理者**に送信します。その所有者は、**共同作成者**ロールと共に、開発環境と運用環境それぞれのリソース グループに追加されます。 前に説明したように、**共同作成者**ロールにより、ユーザーは、別のユーザーへのロールの割り当て以外のすべての操作を実行できます。 最初の**ワークロード所有者**は、自身のワークロードに関連付けられているリソースを作成できます。
    ![](../../_images/governance-3-3.png)
6. 最初の**ワークロード所有者**は、2 つのリソース グループそれぞれに仮想ネットワークを作成します。各仮想ネットワークには 2 つの仮想マシンがあります。 最初の**ワークロード所有者**は、*environment* タグと *managedBy* タグをすべてのリソースに適用します。 Azure サービスの制限カウンターが示す現在の残りの仮想ネットワーク数が 997 であることに注意してください。
    ![](../../_images/governance-3-4.png)
7. 仮想ネットワークが作成されたとき、どちらにもオンプレミスへの接続性はありません。 この種類のアーキテクチャでは、各仮想ネットワークが、**共有インフラストラクチャ**環境の *hub-vnet* にピアリングされていなければなりません。 仮想ネットワークのピアリングにより、2 つの個別の仮想ネットワーク間に接続が作成され、その間をネットワーク トラフィックが行き来できるようになります。 仮想ネットワークのピアリングは、本質的には推移的でないことに注意してください。 ピアリングは、接続されている 2 つの各仮想ネットワークで指定する必要があります。いずれか 1 つの仮想ネットワークでしかピアリングが指定されていない場合、接続は不完全です。 この影響を示すために、最初の**ワークロード所有者**は、**prod-vnet** と **hub-vnet** の間のピアリングを指定します。 この場合、最初のピアリングは作成されますが、トラフィックは行き来しません。**hub-vnet** から **prod-vnet** への補完的なピアリングがまだ指定されていないためです。 最初の**ワークロード所有者**は、**ネットワーク操作**ユーザーに、この補完的なピアリング接続を要求します。
    ![](../../_images/governance-3-5.png)
8. **ネットワーク操作**ユーザーは要求を確認し、承認したうえで、**hub-vnet** の設定でピアリングを指定します。 これでピアリングの接続は完了です。2 つの仮想ネットワーク間を、ネットワーク トラフィックが行き来するようになります。
    ![](../../_images/governance-3-6.png)
9. ここで、もう 1 人の**ワークロード所有者**が要求を**サブスクリプション サービス管理者**に送信します。その所有者は、**共同作成者**ロールと共に、既存の**運用**環境と**開発**環境それぞれのリソース グループに追加されます。 その 2 番目の**ワークロード所有者**には、各リソース グループで、最初の**ワークロード所有者**と同じアクセス許可がすべてのリソースについて付与されます。
    ![](../../_images/governance-3-7.png)
10. 2 番目の**ワークロード所有者**は、**prod vnet** 仮想ネットワークにサブネットを作成し、2 つの仮想マシンを追加します。 2 番目の**ワークロード所有者**は、*environment* タグと *managedBy* タグを各リソースに適用します。
    ![](../../_images/governance-3-8.png)

このリソース管理モデルの例では、3 つの必要な環境でリソースを管理できます。 共有インフラストラクチャ リソースが保護されているのは、それらのリソースへのアクセス許可を持つユーザーが、サブスクリプションに 1 人しかいないためです。 共有インフラストラクチャ リソースは、その実際の共有リソース自体に対するアクセス許可がなくても、各ワークロード所有者が使用できます。 ただし、この管理モデルは、ワークロード分離の要件を満たしておらず、2 人の**ワークロード所有者**それぞれが、もう一方のワークロードのリソースにアクセスできます。

また、一見するとわかりにくいかもしれませんが、このモデルには重要な考慮事項がもう 1 つあります。 この例では、オンプレミスとの接続性を提供するために **hub-vnet** とのネットワーク ピアリング接続を要求したのは、**app1 ワークロード所有者**でした。 **ネットワーク操作**ユーザーは、そのワークロードでデプロイされたリソースに基づいてその要求を評価しました。 **サブスクリプション所有者**が **app2 ワークロード所有者**を、**共同作成者**ロールと共に追加したとき、そのユーザーには、**prod-rg** リソース グループのすべてのリソースに対する管理アクセス権がありました。

![](../../_images/governance-3-10.png)

つまり、**app2 ワークロード所有者**には、**prod-vnet** 仮想ネットワーク内に、自身のサブネットと仮想マシンをデプロイするアクセス許可がありました。 既定では、これで、それらの仮想マシンはオンプレミス ネットワークにアクセスできます。 **ネットワーク操作**ユーザーは、これらのマシンを認識せず、そのマシンがオンプレミスに接続するのを承認しませんでした。

次に、さまざまな環境やワークロードに対するリソース グループが複数含まれる 1 つのサブスクリプションを見てみましょう。 前の例では、リソースは環境ごとに分かれ、同じ環境のリソースは同じリソース グループにあったため、各環境のリソースを簡単に特定できました。 そのグループ分けがなくなり、今後は、リソースを特定するために、リソース グループの名前付け規則を使用する必要があります。

1. **共有インフラストラクチャ** リソースでは引き続きこのモデル内で個別のリソース グループが使用されるため、変更されません。 ワークロードごとに 2 つのリソース グループが必要です。1 つは**開発**環境、もう 1 つは**運用**環境に対して使用されます。 最初のワークロードに対して、**サブスクリプション所有者**は 2 つのリソース グループを作成します。 1 つは **app1-prod-rg**、もう 1 つは **app1-dev-rg** という名前です。 前に説明したように、この名前付け規則により、リソースが、最初のワークロード **app1** と、**dev** 環境または **prod** 環境のいずれかに関連付けられていることが特定されます。 ここでも、"*サブスクリプション*" 所有者は、**app1 ワークロード所有者**を、**共同作成者**ロールと共にリソース グループに追加します。
    ![](../../_images/governance-3-12.png)
2. 最初の例と同様、**app1 ワークロード所有者**が、**app1-prod-vnet** という名前の仮想ネットワークを**運用**環境に、もう 1 つの **app1-dev-vnet** という名前の仮想ネットワークを**開発**環境に追加します。 ここでも、**app1 ワークロード所有者**が、ピアリング接続の作成要求を**ネットワーク操作**ユーザーに送信します。 **app1 ワークロード所有者**が、最初の例と同じタグを追加していることに注意してください。制限カウンターは、サブスクリプションに残っている仮想ネットワークの数を示す 997 に減少しています。
    ![](../../_images/governance-3-13.png)
3. ここで、**サブスクリプション所有者**は、**app2 ワークロード所有者**に対して 2 つのリソース グループを作成します。 **app1 ワークロード所有者**と同じ規則に従って、リソース グループの名前は **app2-prod-rg** と **app2-dev-rg** となります。 **サブスクリプション所有者**は、**app2 ワークロード所有者**を、**共同作成者**ロールと共に各リソース グループに追加します。
    ![](../../_images/governance-3-14.png)
4. "*app2 ワークロード所有者*" が、仮想ネットワークと仮想マシンを、同じ名前付け規則を持つリソース グループにデプロイします。 タグが追加され、制限カウンターは、"*サブスクリプション*" に残っている仮想ネットワークの数を示す 995 に減少しています。
    ![](../../_images/governance-3-15.png)
5. "*app2 ワークロード所有者*" が、"*ネットワーク操作*" ユーザーに対して、*app2-prod-vnet* を *hub-vnet* にピアリングするよう要求します。 "*ネットワーク操作*" ユーザーは、ピアリング接続を作成します。
    ![](../../_images/governance-3-16.png)

結果の管理モデルは最初の例と似ていますが、主に次のような違いがあります。

* 2 つのワークロードはそれぞれ、ワークロードおよび環境によって分離されています。
* このモデルには、最初の例のモデルよりも仮想ネットワークが 2 つ多く必要です。 ワークロードが 2 つだけなので、この違いは重要ではありませんが、このモデルのワークロード数の制限は理論的には 24 個です。
* それぞれの環境に対応する 1 つのリソース グループに、リソースがグループ化されなくなりました。 リソースをグループ化するには、各環境に使用される名前付け規則を理解する必要があります。
* ピアリングされた各仮想ネットワーク接続が、"*ネットワーク操作*" ユーザーによって確認および承認されました。

ここで、複数のサブスクリプションを使用したリソース管理モデルを見てみましょう。 このモデルでは、3 つの各環境を、**共有サービス** サブスクリプション、**運用**サブスクリプション、**開発**サブスクリプションの 3 つの個別のサブスクリプションと連携させます。 このモデルに関する考慮事項は、リソース グループとワークロードを連携させる方法を決める必要がある点では、1 つのサブスクリプションを使用するモデルと似ています。 ワークロードごとにリソース グループを作成すると、ワークロードの分離要件に対応できることは既に確認しました。したがって、この例では、そのモデルをそのまま使用します。

1. このモデルには、"*共有インフラストラクチャ*"、"*運用*"、および "*開発*" の 3 つの "*サブスクリプション*" があります。 この 3 つのサブスクリプションそれぞれに、"*サブスクリプション所有者*" が必要で、このシンプルな例では、3 つすべてに同じユーザー アカウントを使用します。 "*共有インフラストラクチャ*" リソースは、上記の最初の 2 つの例と同じように管理されており、最初のワークロードは、"*運用*" 環境の *app1-rg*と、"*開発*" 環境の同じ名前のリソース グループに関連付けられています。 "*app1 ワークロード所有者*" は、"*共同作成者*" ロールと共に各リソース グループに追加されます。
    ![](../../_images/governance-3-17.png)
2. 前の例と同様に、"*app1 ワークロード所有者*" がリソースを作成し、"*共有インフラストラクチャ*" 仮想ネットワークとのピアリング接続を要求します。 "*app1 ワークロード所有者*" は *managedBy* タグのみを追加します。*environment* タグは必要なくなったためです。 つまり、各環境のリソースが同じ "*サブスクリプション*" にグループ化されるようになり、*environment* タグは不要です。 制限カウンターは、残り 999 仮想ネットワークに減少します。
    ![](../../_images/governance-3-18.png)
3. 最後に、"*サブスクリプション所有者*" は 2 つ目のワークロードに対して処理を繰り返して、共同作成者ロールで "*app2 ワークロード所有者*" を含むリソース グループを追加します。 各環境サブスクリプションの制限カウンターは、残り 998 仮想ネットワークに減少します。

この管理モデルには、上記の 2 番目の例で示した利点があります。 主な違いは、制限が 2 つの "*サブスクリプション*" に分散されるため、あまり問題にはならないという点です。 欠点は、タグによって追跡されるコスト データを、3 つのすべての "*サブスクリプション*" にわたって集計する必要があることです。

したがって、ご自身の要件の優先度に応じて、2 つのサンプル リソース管理モデルのいずれかを選択できます。 皆様の組織で 1 つのサブスクリプションのサービス制限に到達しないと思われる場合は、複数のリソース グループを含む 1 つのサブスクリプションを使用できます。 逆に、組織のワークロードが多くなりそうなときは、環境ごとに複数のサブスクリプションを使用することをお勧めします。

## <a name="implementing-the-resource-management-model"></a>リソース管理モデルの実装

Azure リソースへのアクセスを管理するためのモデルをいくつか取り上げて説明しました。 ここでは、設計ガイドの**共有インフラストラクチャ**環境、**運用**環境、**開発**環境それぞれに、1 つのサブスクリプションが含まれるリソース管理モデルを実装する手順を説明します。 この 3 つの環境すべてに 1 人の**サブスクリプション所有者**がいます。 ワークロードはそれぞれ、**共同作成者**ロールと共に追加された**ワークロード所有者**を含む**リソース グループ**に分離されます。

> [!NOTE]
> Azure アカウントとサブスクリプション間のリレーションシップの詳細については、[Azure でのリソース アクセス][understand-resource-access-in-azure]に関するページをご覧ください。

次の手順に従います。

1. [Azure アカウント](/azure/active-directory/sign-up-organization)を作成します (まだ組織にない場合)。 Azure アカウントにサインアップしたユーザーは、Azure アカウント管理者になります。また、組織の指導者は、このロールを担う個人を選択する必要があります。 この個人は、次を担当します。
    - サブスクリプションの作成。
    - これらのサブスクリプションのユーザー ID が格納される [Azure Active Directory (AD)](/azure/active-directory/active-directory-whatis) テナントの作成と管理。
2. ご自身の組織の指導チームは、次の作業を行う担当者を決めます。
    - ユーザー ID の管理。ご自身の組織の Azure アカウントの作成時に [Azure AD テナント](/azure/active-directory/develop/active-directory-howto-tenant)が既定で作成されます。アカウント管理者は、[Azure AD グローバル管理者](/azure/active-directory/active-directory-assign-admin-roles-azure-portal#details-about-the-global-administrator-role)として既定で追加されます。 ご自身の組織がユーザー ID 管理の担当者として別のユーザーを選択するには、[そのユーザーに Azure AD グローバル管理者ロールを割り当て](/azure/active-directory/active-directory-users-assign-role-azure-portal)ます。
    - サブスクリプション。これらのユーザーは次を行います。
        - そのサブスクリプションのリソース使用量に関連付けられているコストの管理。
        - リソース アクセスのための最小限のアクセス許可モデルの実装と維持。
        - サービス制限の追跡。
    - 共有インフラストラクチャ サービス (ご自身の組織がこのモデルの使用を決めた場合)。このユーザーは次を担当します。
        - オンプレミスと Azure ネットワークの接続。
        - Azure 内での仮想ネットワーク ピアリング経由のネットワーク接続の所有権。
    - ワークロード所有者。
3. Azure AD グローバル管理者は、次に対する[ユーザー アカウントを新しく作成](/azure/active-directory/add-users-azure-active-directory)します。
    - 各環境に関連付けられている各サブスクリプションの**サブスクリプション所有者**になる人。 これは、サブスクリプション **サービス管理者**に、各サブスクリプション/環境のリソース アクセス管理のタスクが割り当てられない場合にのみ必要です。
    - **ネットワーク操作ユーザー**になる人。
    - **ワークロード所有者**になる人。
4. Azure アカウント管理者は、[Azure アカウント ポータル](https://account.azure.com)を使用して、次の 3 つのサブスクリプションを作成します。
    - **共有インフラストラクチャ**環境のサブスクリプション。
    - **運用**環境のサブスクリプション。
    - **開発**環境のサブスクリプション。
5. Azure アカウント管理者は、[サブスクリプション サービス所有者を各サブスクリプションに追加](/azure/billing/billing-add-change-azure-subscription-administrator#add-an-rbac-owner-admin-for-a-subscription-in-azure-portal)します。
6. **ワークロード所有者**の承認プロセスを作成して、リソース グループの作成を要求します。 承認プロセスは、さまざまな方法で実装できます。たとえば、電子メールや、[SharePoint ワークフロー](https://support.office.com/article/introduction-to-sharepoint-workflow-07982276-54e8-4e17-8699-5056eff4d9e3)などのプロセス管理ツールを使用できます。 承認プロセスでは、次の手順に従うことができます。
    - **ワークロード所有者**は、**開発**環境、**運用**環境、またはその両方で、必要な Azure リソースの部品表を準備して、**サブスクリプション所有者**に送信します。
    - **サブスクリプション所有者**は部品表を確認し、要求されたリソースを検証して、そのリソースが計画的な使用に適していることを確かめます。たとえば、要求された[仮想マシンのサイズ](/azure/virtual-machines/windows/sizes)が正しいことをチェックします。
    - 要求が承認されなかった場合は、**ワークロード所有者**に通知されます。 要求が承認された場合、**サブスクリプション所有者**は、自分の組織の[名前付け規則](/azure/architecture/best-practices/naming-conventions)に従って[要求されたリソース グループを作成](/azure/azure-resource-manager/resource-group-portal#manage-resource-groups)し、[**共同作成者**ロール](/azure/role-based-access-control/built-in-roles#contributor)と共に[**ワークロード所有者**を追加](/azure/role-based-access-control/role-assignments-portal#add-access)して、リソース グループが作成されたことを**ワークロード所有者**に通知します。
7. ワークロード所有者の承認プロセスを作成して、仮想ネットワーク ピアリング接続を共有インフラストラクチャ所有者に要求します。 前の手順と同様に、この承認プロセスは、電子メールまたはプロセス管理ツールを使用して実装できます。

ガバナンス モデルが実装されたので、共有インフラストラクチャ サービスをデプロイできます。

## <a name="next-steps"></a>次の手順

> [!div class="nextstepaction"]
> [基本的なインフラストラクチャのデプロイについて確認する](../../infrastructure/basic-workload.md)

<!-- links -->
[understand-resource-access-in-azure]: /azure/role-based-access-control/rbac-and-directory-admin-roles

[rbac-built-in-owner]: /azure/role-based-access-control/built-in-roles#owner
[rbac-built-in-roles]: /azure/role-based-access-control/built-in-roles
