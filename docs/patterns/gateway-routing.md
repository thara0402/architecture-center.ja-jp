---
title: ゲートウェイ ルーティング パターン
description: 単一のエンドポイントを使用して複数のサービスに要求をルーティングします。
author: dragon119
ms.date: 06/23/2017
ms.openlocfilehash: ea0bc4d31b745043a7ac3afb277dfc46d87ff109
ms.sourcegitcommit: 85334ab0ccb072dac80de78aa82bcfa0f0044d3f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/11/2018
ms.locfileid: "35252602"
---
# <a name="gateway-routing-pattern"></a>ゲートウェイ ルーティング パターン

単一のエンドポイントを使用して複数のサービスに要求をルーティングします。 このパターンは、単一のエンドポイントで複数のサービスを公開し、要求に基づいて適切なサービスにルーティングする場合に便利です。

## <a name="context-and-problem"></a>コンテキストと問題

クライアントが複数のサービスを使用する必要がある場合、サービスごとに個別のエンドポイントを設定し、クライアントが各エンドポイントを管理するのは難しい場合があります。 たとえば、電子商取引アプリケーションが、検索、レビュー、カート、チェックアウト、注文履歴などのサービスを提供しているとします。 クライアントが対話する必要のある API がサービスごとに異なり、クライアントはサービスに接続するために、各エンドポイントを把握する必要があります。 API が変更された場合、クライアントも更新する必要があります。 サービスを複数の個別のサービスにリファクタリングする場合は、サービスとクライアントの両方でコードを変更する必要があります。

## <a name="solution"></a>解決策

一連のアプリケーション、サービス、またはデプロイの前にゲートウェイを配置します。 アプリケーションのレイヤー 7 ルーティングを使用して、要求を適切なインスタンスにルーティングします。

このパターンでは、クライアント アプリケーションは、単一のエンドポイントを把握し、そのエンドポイントと通信するだけで済みます。 サービスが統合または分解されても、クライアントを必ずしも更新する必要はありません。 引き続きゲートウェイに要求することができ、ルーティングだけが変更されます。

また、ゲートウェイにより、クライアントからバックエンド サービスを抽象化できるので、ゲートウェイの背後でバックエンド サービスの変更を可能にしながら、クライアント呼び出しをシンプルに保つことができます。 クライアント呼び出しは、クライアントの予想される動作を処理する必要がある 1 つまたは複数のサービスにルーティングできるので、クライアントを変更せずに、ゲートウェイの背後でサービスを追加、分割、再構成できます。

![](./_images/gateway-routing.png)
 
このパターンは、更新プログラムをユーザーにロールアウトする方法を管理できるため、デプロイでも役立ちます。 サービスの新しいバージョンをデプロイするときは、既存のバージョンと並行してデプロイできます。 ルーティングにより、クライアントに提示するサービスのバージョンを制御できるため、更新プログラムのロールアウトが増分、並列、完全のいずれであるかを問わず、さまざまなリリース戦略を使用する柔軟がもたらされます。 新しいサービスのデプロイ後に問題が見つかった場合、ゲートウェイで構成変更を行うことで、クライアントに影響を及ぼすことなく、簡単に元に戻すことができます。

## <a name="issues-and-considerations"></a>問題と注意事項

- ゲートウェイ サービスによって、単一障害点が生じる可能性があります。 可用性の要件が満たされるように、適切に設計されていることを確認します。 実装時の回復性とフォールト トレランス機能を検討してください。
- ゲートウェイ サービスによって、ボトルネックが生じる可能性があります。 ゲートウェイが負荷を処理できる十分なパフォーマンスを備えており、成長予測に合わせて簡単に拡張できることを確認します。
- サービスのカスケードのエラーが発生しないように、ゲートウェイに対してロード テストを実行します。
- ゲートウェイ ルーティングはレベル 7 です。 IP、ポート、ヘッダー、または URL に基づくことができます。

## <a name="when-to-use-this-pattern"></a>このパターンを使用する状況

このパターンは次の状況で使用します。

- クライアントが、ゲートウェイの背後でアクセスできる複数のサービスを使用する必要がある場合。
- 単一のエンドポイントを使用することで、クライアント アプリケーションを簡素化する場合。
- 外部でアドレス指定可能なエンドポイントから内部仮想エンドポイントに要求をルーティングする必要がある場合 (VM のポートをクラスターの仮想 IP アドレスに公開する場合など)。

このパターンは、1 つか 2 つのサービスしか使用しない単純なアプリケーションには適していないことがあります。

## <a name="example"></a>例

ルーターとして Nginx を使用して、さまざまな仮想ディレクトリに存在するアプリケーションの要求を、それぞれバックエンドの異なるコンピューターにルーティングするサーバーの構成ファイルの簡単な例を次に示します。

```
server {
    listen 80;
    server_name domain.com;

    location /app1 {
        proxy_pass http://10.0.3.10:80;
    }

    location /app2 {
        proxy_pass http://10.0.3.20:80;
    }

    location /app3 {
        proxy_pass http://10.0.3.30:80;
    }
}
```

## <a name="related-guidance"></a>関連するガイダンス

- [フロントエンド用バックエンド パターン](./backends-for-frontends.md)
- [Gateway Aggregation pattern](./gateway-aggregation.md) (ゲートウェイ集約パターン)
- [ゲートウェイ オフロード パターン](./gateway-offloading.md)



