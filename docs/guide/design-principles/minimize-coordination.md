---
title: 調整を最小限に抑える
titleSuffix: Azure Application Architecture Guide
description: アプリケーション サービス間の調整を最小限に抑えてスケーラビリティを実現します。
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: e124e6720b909bafc74a4c074454ec0a3ec30c59
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/23/2019
ms.locfileid: "54488581"
---
# <a name="minimize-coordination"></a><span data-ttu-id="4204d-103">調整を最小限に抑える</span><span class="sxs-lookup"><span data-stu-id="4204d-103">Minimize coordination</span></span>

## <a name="minimize-coordination-between-application-services-to-achieve-scalability"></a><span data-ttu-id="4204d-104">アプリケーション サービス間の調整を最小限に抑えてスケーラビリティを実現する</span><span class="sxs-lookup"><span data-stu-id="4204d-104">Minimize coordination between application services to achieve scalability</span></span>

<span data-ttu-id="4204d-105">ほとんどのクラウド アプリケーションは、複数のアプリケーション サービスで構成されています&mdash;Web フロント エンド、データベース、ビジネス プロセス、レポートおよび分析などです。</span><span class="sxs-lookup"><span data-stu-id="4204d-105">Most cloud applications consist of multiple application services &mdash; web front ends, databases, business processes, reporting and analysis, and so on.</span></span> <span data-ttu-id="4204d-106">スケーラビリティと信頼性を実現するには、それらのサービスの各々を複数のインスタンスで実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4204d-106">To achieve scalability and reliability, each of those services should run on multiple instances.</span></span>

<span data-ttu-id="4204d-107">2 つのインスタンスが、共有状態に影響する操作を同時に実行しようとすると、どうなるでしょうか。</span><span class="sxs-lookup"><span data-stu-id="4204d-107">What happens when two instances try to perform concurrent operations that affect some shared state?</span></span> <span data-ttu-id="4204d-108">場合によっては、たとえば、ACID 保証を維持するために、ノード間で調整の必要があります。</span><span class="sxs-lookup"><span data-stu-id="4204d-108">In some cases, there must be coordination across nodes, for example to preserve ACID guarantees.</span></span> <span data-ttu-id="4204d-109">この図では、`Node2` は `Node1` がデータベース ロックを解放するのを待っています。</span><span class="sxs-lookup"><span data-stu-id="4204d-109">In this diagram, `Node2` is waiting for `Node1` to release a database lock:</span></span>

![データベース ロックの図](./images/database-lock.svg)

<span data-ttu-id="4204d-111">調整は水平スケールの利点を制限し、ボトルネックを作り出します。</span><span class="sxs-lookup"><span data-stu-id="4204d-111">Coordination limits the benefits of horizontal scale and creates bottlenecks.</span></span> <span data-ttu-id="4204d-112">この例では、アプリケーションをスケールアウトしてより多くのインスタンスを追加すると、ロックの競合が増加することがわかります。</span><span class="sxs-lookup"><span data-stu-id="4204d-112">In this example, as you scale out the application and add more instances, you'll see increased lock contention.</span></span> <span data-ttu-id="4204d-113">最悪の場合、フロント エンド インスタンスはほとんどの時間をロック待機に費やします。</span><span class="sxs-lookup"><span data-stu-id="4204d-113">In the worst case, the front-end instances will spend most of their time waiting on locks.</span></span>

<span data-ttu-id="4204d-114">"1 回限り" のセマンティクスは、もう 1 つのよくある調整の発生源です。</span><span class="sxs-lookup"><span data-stu-id="4204d-114">"Exactly once" semantics are another frequent source of coordination.</span></span> <span data-ttu-id="4204d-115">たとえば、1 つの注文は 1 回だけ処理されなければいけません。</span><span class="sxs-lookup"><span data-stu-id="4204d-115">For example, an order must be processed exactly once.</span></span> <span data-ttu-id="4204d-116">2 つのワーカーが新しい注文をリッスンしています。</span><span class="sxs-lookup"><span data-stu-id="4204d-116">Two workers are listening for new orders.</span></span> <span data-ttu-id="4204d-117">`Worker1` は、1 つの注文を処理するために取得します。</span><span class="sxs-lookup"><span data-stu-id="4204d-117">`Worker1` picks up an order for processing.</span></span> <span data-ttu-id="4204d-118">アプリケーションは `Worker2` がこの作業を重複しないように、しかしまた、もし `Worker1` がクラッシュしたらこの注文が抜け落ちないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4204d-118">The application must ensure that `Worker2` doesn't duplicate the work, but also if `Worker1` crashes, the order isn't dropped.</span></span>

![調整の図](./images/coordination.svg)

<span data-ttu-id="4204d-120">[Scheduler Agent Supervisor][sas-pattern] のようなパターンを使用してワーカー間を調整することができますが、ここでは、作業を分割するのがより適切な方法かもしれません。</span><span class="sxs-lookup"><span data-stu-id="4204d-120">You can use a pattern such as [Scheduler Agent Supervisor][sas-pattern] to coordinate between the workers, but in this case a better approach might be to partition the work.</span></span> <span data-ttu-id="4204d-121">各ワーカーには、注文の特定の範囲 (たとえば、請求先リージョンごと) が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="4204d-121">Each worker is assigned a certain range of orders (say, by billing region).</span></span> <span data-ttu-id="4204d-122">ワーカーがクラッシュした場合、新しいインスタンスは直前のインスタンスが中断された場所を取得しますが、複数のインスタンスは競合しません。</span><span class="sxs-lookup"><span data-stu-id="4204d-122">If a worker crashes, a new instance picks up where the previous instance left off, but multiple instances aren't contending.</span></span>

## <a name="recommendations"></a><span data-ttu-id="4204d-123">Recommendations</span><span class="sxs-lookup"><span data-stu-id="4204d-123">Recommendations</span></span>

<span data-ttu-id="4204d-124">**最終的な整合性の受容**。</span><span class="sxs-lookup"><span data-stu-id="4204d-124">**Embrace eventual consistency**.</span></span> <span data-ttu-id="4204d-125">データを分散すると、強力な整合性を保証するには調整が必要になります。</span><span class="sxs-lookup"><span data-stu-id="4204d-125">When data is distributed, it takes coordination to enforce strong consistency guarantees.</span></span> <span data-ttu-id="4204d-126">たとえば、1 つの操作が 2 つのデータベースを更新するとします。</span><span class="sxs-lookup"><span data-stu-id="4204d-126">For example, suppose an operation updates two databases.</span></span> <span data-ttu-id="4204d-127">1 つのトランザクション スコープに入れるのではなく、そのシステムが最終的な整合性に対応できるのであれば (おそらく[補正トランザクション][compensating-transaction]パターンを使用して)、エラーの後に論理的にロールバックするほうがよいでしょう。</span><span class="sxs-lookup"><span data-stu-id="4204d-127">Instead of putting it into a single transaction scope, it's better if the system can accommodate eventual consistency, perhaps by using the [Compensating Transaction][compensating-transaction] pattern to logically roll back after a failure.</span></span>

<span data-ttu-id="4204d-128">**ドメイン イベントを使用した状態の同期**。</span><span class="sxs-lookup"><span data-stu-id="4204d-128">**Use domain events to synchronize state**.</span></span> <span data-ttu-id="4204d-129">[ドメイン イベント][domain-event]は、ドメイン内で重要な出来事が発生したときに記録するイベントです。</span><span class="sxs-lookup"><span data-stu-id="4204d-129">A [domain event][domain-event] is an event that records when something happens that has significance within the domain.</span></span> <span data-ttu-id="4204d-130">対象サービスは、グローバル トランザクションを使用して複数サービスを調整するのではなく、このイベントをリッスンすることができます。</span><span class="sxs-lookup"><span data-stu-id="4204d-130">Interested services can listen for the event, rather than using a global transaction to coordinate across multiple services.</span></span> <span data-ttu-id="4204d-131">この手法を使用する場合、システムは最終的な整合性を許容する必要があります (前の項目を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="4204d-131">If this approach is used, the system must tolerate eventual consistency (see previous item).</span></span>

<span data-ttu-id="4204d-132">**CQRS およびイベント ソーシングなどのパターンの検討**。</span><span class="sxs-lookup"><span data-stu-id="4204d-132">**Consider patterns such as CQRS and event sourcing**.</span></span> <span data-ttu-id="4204d-133">これら 2 つのパターンは、読み取りワークロードと書き込みワークロードの競合を削減するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4204d-133">These two patterns can help to reduce contention between read workloads and write workloads.</span></span>

- <span data-ttu-id="4204d-134">[CQRS パターン][cqrs-pattern]は、書き込み操作と読み取り操作を分けます。</span><span class="sxs-lookup"><span data-stu-id="4204d-134">The [CQRS pattern][cqrs-pattern] separates read operations from write operations.</span></span> <span data-ttu-id="4204d-135">一部の実装では、読み取りデータは書き込みデータから物理的に分離されます。</span><span class="sxs-lookup"><span data-stu-id="4204d-135">In some implementations, the read data is physically separated from the write data.</span></span>

- <span data-ttu-id="4204d-136">[イベント ソーシングのパターン][event-sourcing]では、状態の変更は、一連のイベントとして追加専用のデータ ストアに記録されます。</span><span class="sxs-lookup"><span data-stu-id="4204d-136">In the [Event Sourcing pattern][event-sourcing], state changes are recorded as a series of events to an append-only data store.</span></span> <span data-ttu-id="4204d-137">ストリームへのイベント追加はアトミック操作であり、最小限のロックを必要とします。</span><span class="sxs-lookup"><span data-stu-id="4204d-137">Appending an event to the stream is an atomic operation, requiring minimal locking.</span></span>

<span data-ttu-id="4204d-138">これら 2 つのパターンは、相互に補完します。</span><span class="sxs-lookup"><span data-stu-id="4204d-138">These two patterns complement each other.</span></span> <span data-ttu-id="4204d-139">CQRS の書き込み専用ストアでイベント ソーシングを使用する場合は、読み取り専用ストアは同じイベントをリッスンして、クエリ用に最適化された、現在の状態の読み取り可能なスナップショットを作成することができます。</span><span class="sxs-lookup"><span data-stu-id="4204d-139">If the write-only store in CQRS uses event sourcing, the read-only store can listen for the same events to create a readable snapshot of the current state, optimized for queries.</span></span> <span data-ttu-id="4204d-140">ただし、CQRS またはイベント ソーシングを採用するときは、この手法についての課題に注意してください。</span><span class="sxs-lookup"><span data-stu-id="4204d-140">Before adopting CQRS or event sourcing, however, be aware of the challenges of this approach.</span></span> <span data-ttu-id="4204d-141">詳細については、[CQRS アーキテクチャ スタイル][cqrs-style]に関する記事をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="4204d-141">For more information, see [CQRS architecture style][cqrs-style].</span></span>

<span data-ttu-id="4204d-142">**データのパーティション分割**。</span><span class="sxs-lookup"><span data-stu-id="4204d-142">**Partition data**.</span></span>  <span data-ttu-id="4204d-143">すべてのデータを、多くのアプリケーション サービス間で共有されている 1 つのデータ スキーマに配置することは避けます。</span><span class="sxs-lookup"><span data-stu-id="4204d-143">Avoid putting all of your data into one data schema that is shared across many application services.</span></span> <span data-ttu-id="4204d-144">マイクロサービス アーキテクチャでは、各サービスにそれ自身のデータ ストアを担当させることにより、この原則を強制します。</span><span class="sxs-lookup"><span data-stu-id="4204d-144">A microservices architecture enforces this principle by making each service responsible for its own data store.</span></span> <span data-ttu-id="4204d-145">1 つのデータベース内では、データをシャードに分割するとコンカレンシーを向上させることができますが、これは、1 つのシャードへ書き込むサービスは別のシャードに書き込むサービスに影響しないからです。</span><span class="sxs-lookup"><span data-stu-id="4204d-145">Within a single database, partitioning the data into shards can improve concurrency, because a service writing to one shard does not affect a service writing to a different shard.</span></span>

<span data-ttu-id="4204d-146">**べき等操作の設計**。</span><span class="sxs-lookup"><span data-stu-id="4204d-146">**Design idempotent operations**.</span></span> <span data-ttu-id="4204d-147">可能であれば、操作がべき等になるように設計します。</span><span class="sxs-lookup"><span data-stu-id="4204d-147">When possible, design operations to be idempotent.</span></span> <span data-ttu-id="4204d-148">こうすれば、1 回以上のセマンティクスを使用して、それらを処理できます。</span><span class="sxs-lookup"><span data-stu-id="4204d-148">That way, they can be handled using at-least-once semantics.</span></span> <span data-ttu-id="4204d-149">たとえば、1 つのキューに作業項目を配置します。</span><span class="sxs-lookup"><span data-stu-id="4204d-149">For example, you can put work items on a queue.</span></span> <span data-ttu-id="4204d-150">1 つの操作の途中でワーカーがクラッシュしたら、別のワーカーがその作業項目を取得するだけです。</span><span class="sxs-lookup"><span data-stu-id="4204d-150">If a worker crashes in the middle of an operation, another worker simply picks up the work item.</span></span>

<span data-ttu-id="4204d-151">**非同期の並列処理の使用**。</span><span class="sxs-lookup"><span data-stu-id="4204d-151">**Use asynchronous parallel processing**.</span></span> <span data-ttu-id="4204d-152">1 つの操作で、非同期に実行される複数の手順 (リモート サービスの呼び出しなど) が必要な場合は、それらを並列で呼び出してから、結果を集計することができます。</span><span class="sxs-lookup"><span data-stu-id="4204d-152">If an operation requires multiple steps that are performed asynchronously (such as remote service calls), you might be able to call them in parallel, and then aggregate the results.</span></span> <span data-ttu-id="4204d-153">この方法では、各々の手順が直前の手順の結果に依存しないことを前提としています。</span><span class="sxs-lookup"><span data-stu-id="4204d-153">This approach assumes that each step does not depend on the results of the previous step.</span></span>

<span data-ttu-id="4204d-154">**オプティミスティック コンカレンシーの使用 (可能な場合)**。</span><span class="sxs-lookup"><span data-stu-id="4204d-154">**Use optimistic concurrency when possible**.</span></span> <span data-ttu-id="4204d-155">ペシミスティック コンカレンシー制御は、競合を防ぐためにデータベース ロックを使用します。</span><span class="sxs-lookup"><span data-stu-id="4204d-155">Pessimistic concurrency control uses database locks to prevent conflicts.</span></span> <span data-ttu-id="4204d-156">これはパフォーマンスの低下を発生させ、可用性を低下させる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4204d-156">This can cause poor performance and reduce availability.</span></span> <span data-ttu-id="4204d-157">オプティミスティック コンカレンシーでは、各トランザクションは、データのコピーまたはスナップショットを変更します。</span><span class="sxs-lookup"><span data-stu-id="4204d-157">With optimistic concurrency control, each transaction modifies a copy or snapshot of the data.</span></span> <span data-ttu-id="4204d-158">トランザクションがコミットされると、データベース エンジンはトランザクションを検証し、データベースの整合性に影響を与えるトランザクションを拒否します。</span><span class="sxs-lookup"><span data-stu-id="4204d-158">When the transaction is committed, the database engine validates the transaction and rejects any transactions that would affect database consistency.</span></span>

<span data-ttu-id="4204d-159">Azure SQL Database および SQL Server は、[スナップショット分離][sql-snapshot-isolation]によってオプティミスティック コンカレンシーをサポートします。</span><span class="sxs-lookup"><span data-stu-id="4204d-159">Azure SQL Database and SQL Server support optimistic concurrency through [snapshot isolation][sql-snapshot-isolation].</span></span> <span data-ttu-id="4204d-160">一部の Azure ストレージ サービスは、[Azure Cosmos DB][cosmosdb-faq] および [Azure Storage][storage-concurrency] を含む Etag を使用して、オプティミスティック コンカレンシーをサポートします。</span><span class="sxs-lookup"><span data-stu-id="4204d-160">Some Azure storage services support optimistic concurrency through the use of Etags, including [Azure Cosmos DB][cosmosdb-faq] and [Azure Storage][storage-concurrency].</span></span>

<span data-ttu-id="4204d-161">**MapReduce またはその他の並列の分散アルゴリズムの検討**。</span><span class="sxs-lookup"><span data-stu-id="4204d-161">**Consider MapReduce or other parallel, distributed algorithms**.</span></span> <span data-ttu-id="4204d-162">実行するデータと作業の種類によっては、作業を、並行して動作する複数のノードで実行できる独立したタスクに分割することができます。</span><span class="sxs-lookup"><span data-stu-id="4204d-162">Depending on the data and type of work to be performed, you may be able to split the work into independent tasks that can be performed by multiple nodes working in parallel.</span></span> <span data-ttu-id="4204d-163">[大規模なコンピューティング アーキテクチャ スタイル][big-compute]に関する記事をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="4204d-163">See [Big compute architecture style][big-compute].</span></span>

<span data-ttu-id="4204d-164">**調整でのリーダー選択の使用**。</span><span class="sxs-lookup"><span data-stu-id="4204d-164">**Use leader election for coordination**.</span></span> <span data-ttu-id="4204d-165">操作を調整する必要がある場合、コーディネーターがアプリケーションの単一障害点にならないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="4204d-165">In cases where you need to coordinate operations, make sure the coordinator does not become a single point of failure in the application.</span></span> <span data-ttu-id="4204d-166">[リーダー選択パターン][leader-election]を使用すると、1 つのインスタンスはいつでもリーダーで、コーディネーターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="4204d-166">Using the [Leader Election pattern][leader-election], one instance is the leader at any time, and acts as the coordinator.</span></span> <span data-ttu-id="4204d-167">このリーダーが失敗した場合、新しいインスタンスがリーダーに選択されます。</span><span class="sxs-lookup"><span data-stu-id="4204d-167">If the leader fails, a new instance is elected to be the leader.</span></span>

<!-- links -->

[big-compute]: ../architecture-styles/big-compute.md
[compensating-transaction]: ../../patterns/compensating-transaction.md
[cqrs-style]: ../architecture-styles/cqrs.md
[cqrs-pattern]: ../../patterns/cqrs.md
[cosmosdb-faq]: /azure/cosmos-db/faq
[domain-event]: https://martinfowler.com/eaaDev/DomainEvent.html
[event-sourcing]: ../../patterns/event-sourcing.md
[leader-election]: ../../patterns/leader-election.md
[sas-pattern]: ../../patterns/scheduler-agent-supervisor.md
[sql-snapshot-isolation]: /sql/t-sql/statements/set-transaction-isolation-level-transact-sql
[storage-concurrency]: https://azure.microsoft.com/blog/managing-concurrency-in-microsoft-azure-storage-2/